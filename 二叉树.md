# 二叉树理论基础
## 二叉树的种类
### 1. 满二叉树：
只有度为0或者度为2的节点，并且度为0的节点在同一层上，称为满二叉树
![image.png](https://img-blog.csdnimg.cn/20200806185805576.png)
其深度为k，节点数为2^k - 1

### 2. 完全二叉树:
除了最底层节点可能没有填满外，其余每层节点数都达到了最大值，并且最下面一层的节点都集中在改成最左边的若干位置。
![img=png](https://img-blog.csdnimg.cn/20200920221638903.png)
**堆就是一颗完全二叉树，同时保证父子节点的顺序关系**

### 3. 二叉搜索树
二叉搜索树是有数值的，**二叉搜索树是一个有序树**
- 若它的左子树不为空，则左子树上所有节点的值均小于它的根节点的值
- 若它的右子树不为空，则右子树上所有节点的值均大于它的根节点的值
- 它的左右子树也都是二叉搜索树
![img=png](https://img-blog.csdnimg.cn/20200806190304693.png)

### 4. 平衡二叉搜索树
又称为AVL树，具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树。

![img=png](https://img-blog.csdnimg.cn/20200806190511967.png)

## 二叉树的存储方式
**二叉树可以链式存储，也可是顺序存储**
链式存储：
![img=png](https://img-blog.csdnimg.cn/2020092019554618.png)

顺序存储：
![img=png](https://img-blog.csdnimg.cn/20200920200429452.png)

一般都是使用链式存储二叉树，但是数组依然可以表示二叉树

## 二叉树的遍历方式
主要分为两种：
1. 深度优先遍历
2. 广度优先遍历

- 深度优先
    - 前序遍历（递归法，迭代法）
    - 中序遍历（递归法，迭代法）
    - 后序遍历（递归法，迭代法）
- 广度优先搜索
    - 层次遍历（迭代法）

**前中后顺序遍历，其实指的就是中间节点的遍历顺序**，只需要记住前中后序指的就是中间节点的位置就可以了。

- 前序遍历：中左右
- 中序遍历：左中右
- 后序遍历：左右中

![img=png](https://img-blog.csdnimg.cn/20200806191109896.png)

java中二叉树节点的定义：
```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode rgiht;
    public TreeNode(int val) {
        this.val = val;
    }
    public TreeNode(int x, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```
# 二叉树的递归遍历
递归的三要素，**每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！**
1. 确认递归函数的参数和返回值
2. 确定终止条件
3. 确定单层递归的逻辑

```C++
void traversal(TreeNode* cur, vector<int>& vec) { //1. 确认递归函数的参数和返回值
    if (cur == NULL) return; //2. 确定终止条件
    //3. 确定单层递归的逻辑
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中
    traversal(cur->right, vec); // 右
}
```

前中后序遍历：
前序：

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        traversal(root, res);
        return res;
    }
    public void traversal(TreeNode root, List<Integer> res) {
        if(root==null) {
            return;
        }
        res.add(root.val);
        traversal(root.left, res);
        traversal(root.right, res);
    }
}
```

后序：

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        traversal(root, res);
        return res;
    }

    public void traversal(TreeNode root, List<Integer> res) {
        if(root == null) {
            return;
        }
        traversal(root.left, res);
        traversal(root.right, res);
        res.add(root.val);
    }
}
```

中序：

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        traversal(root, res);
        return res;
    }

    public void traversal(TreeNode root, List<Integer> res) {
        if(root == null) return;

        traversal(root.left, res);
        res.add(root.val);
        traversal(root.right, res);
    }
}
```

# 二叉树的迭代遍历

前序：入栈之后，访问的节点和处理的节点是一致的

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        //使用迭代法来进行二叉树的前序遍历
        //使用栈来处理，前序遍历节点遍历和访问元素的顺序是一致
        // 前序遍历顺序：中-左-右，入栈顺序：中-右-左
        Deque<TreeNode> stack = new LinkedList<>();
        List<Integer> list = new ArrayList<>();

        stack.push(root);
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if(node != null) {
                list.add(node.val);      //中
                stack.push(node.right);  //右
                stack.push(node.left);   //左
            }
        }
        return list;
    }
}
```


中序：入栈之后，访问的节点和处理的节点不一致


```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        //迭代法中序遍历二叉树
        //中序遍历的顺序，左中右，入栈顺序：左右，直到左边为空节点才处理节点
        Deque<TreeNode> stack = new LinkedList<>();
        List<Integer> list = new ArrayList<>();
        TreeNode curr = root;
        //注意这里的判断条件，为了保证第一次循环能开始则加入 curr != null
        while(curr !=null || !stack.isEmpty()) {
            if(curr != null) {
                stack.push(curr);
                curr = curr.left;
            } else {
                curr = stack.pop();
                list.add(curr.val);
                curr = curr.right;
            }
        }
        return list;
    }
}
```


后序：可以通过调整前序遍历，并反转数组的方法得到


```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        //后续遍历迭代法
        //修改前序遍历，前序遍历的顺序是中左右，将其改成中右左，然后再反转结果变成左右中
        Deque<TreeNode> stack = new LinkedList<>();
        List<Integer> list = new ArrayList<>();

        stack.push(root);
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if(node != null) {
                list.add(node.val);
                stack.push(node.left);
                stack.push(node.right);
            }
        }
        Collections.reverse(list);
        return list;
    }
}
```

# 二叉树的统一迭代法
统一写法：前面提到的迭代遍历方法**无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况**

**那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**

如何标记呢？**就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。**

统一迭代法比较难理解，还是使用前面的迭代遍历吧

# 二叉树的层序遍历
[leetcode](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)
思路：使用队列来进行存储
**队列先进先出，符合一层一层遍历的逻辑**
![img=gif](https://tva1.sinaimg.cn/large/008eGmZEly1gnad5itmk8g30iw0cqe83.gif)

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        //使用队列解决层次遍历
        //根节点入队列
        //然后将队头元素出队列，并保存，将左右节点压入队列
        if(root == null) {
            return new ArrayList<>();
        }
        Queue<TreeNode> que = new LinkedList<>();
        List<List<Integer>> res = new ArrayList<>();
        que.offer(root);
        while(!que.isEmpty()) {
            int size = que.size();
            List<Integer> list = new ArrayList<>();
            for(int i = 0; i < size; i++) {//这里size是固定的，每一个for循环代表一层
                TreeNode node = que.poll();
                list.add(node.val);
                if(node.left != null) que.offer(node.left);
                if(node.right != null) que.offer(node.right);
            }
            res.add(list);
        }
        return res;
    }
}
```

# 1. 翻转二叉树

## 方法一：递归法
[leetcode](https://leetcode-cn.com/problems/invert-binary-tree/)

思路：
使用递归法，对树进行**前序遍历**，每次遍历都将其左右节点翻转

> 注意：这道题，前序遍历和后序遍历都可以，但是不能中序遍历，可以拿纸画一画，就理解了

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        //DFS
        //使用递归方法
        //1. 确定参数和返回值
        //2. 确定终止条件
        //3. 检查方法体中的语句
        invert(root);
        return root;
    }

    public void invert(TreeNode root) {
        if(root == null) {
            return;
        }
        TreeNode temp = root.left;  //中
        root.left = root.right;
        root.right = temp;
        invert(root.left);          //左
        invert(root.right);         //右
    }
}
```

## 方法二：迭代法-深度优先
思路：
1. 迭代法使用栈
2. 其为前序遍历，遍历的次序和处理（翻转二叉树）的次序是一致

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        //DFS
        //使用迭代法：通过栈来实现
        //构建栈
        //前序遍历，中左右，遍历顺序和处理顺序一致
        if(root == null) {
            return root;
        }
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();
            TreeNode temp = node.left;                      //中
            node.left = node.right;
            node.right = temp;
            if(node.right != null) stack.push(node.right); //右，为了保证出栈是左右，先放入右，再放入左
            if(node.left != null) stack.push(node.left);   //左
        }
        return root;
    
    }
}
```

## 方法三：迭代法-广度优先遍历
思路：
1. 使用队列
2. 按照广度优先遍历的顺序翻转二叉树即可

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        //BFS
        //1. 使用队列
        //2. 按照广度优先遍历的顺序翻转二叉树即可
        if(root == null) {
            return null;
        }
        Queue<TreeNode> que = new LinkedList<>();
        que.offer(root);
        while(!que.isEmpty()) {
            int size = que.size();
            for(int i = 0; i < size; i++) {
                TreeNode node = que.poll();
                TreeNode temp = node.left;
                node.left = node.right;
                node.right = temp;
                if(node.left != null) que.offer(node.left);
                if(node.right != null) que.offer(node.right);
            }
        }
        return root;
    }
}
```

# 2. 对称二叉树
## 方法一：递归法
思路：
1. 采用后序遍历，左子树是左右中，右子树是右左中
2. 递归法：
    1. 确定参数和返回值：比较的左子树节点和右子树节点，返回值是boolean类型
    2. 确定终止条件：节点为空的情况有：
        - 左子节点和右子节点为空，对称 return true
        - 左子节点为空，右子节点不为空，不对称 return false
        - 左子节点不为空，右子节点为空，不对称 return false
        
        此时已经排除了节点为空的情况
        - 左右都不为空，比较结束数值，不相同就 return false
        
    3. 确定单层递归的逻辑
        - 比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子
        - 比较内侧是否对称：传入的是左节点的右孩子，右节点的左孩子
        - 如果左右都对称就返回 true，有一侧不对称就返回 false

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        //思路：实际上该题是比较根节点的左右两棵树
        //只能采用后序遍历的方式
        //左子树是左右中，右子树是右左中
        //采用递归法
        //1. 确定参数和返回值
        //2. 确定终止条件
        //3. 确定递归的语句
        if(root == null) return false;
        TreeNode leftNode = root.left;
        TreeNode rightNode = root.right;
        return travel(leftNode, rightNode);
    }

    public boolean travel(TreeNode leftNode, TreeNode rightNode) {
        if(leftNode == null && rightNode == null) {
            return true;
        } else if(leftNode == null && rightNode != null) {
            return false;
        } else if(leftNode != null && rightNode == null) {
            return false;
        } else if(leftNode.val != rightNode.val) { //注意这里不是else
            return false;
        }

        boolean outside = travel(leftNode.left, rightNode.right);
        boolean inside = travel(leftNode.right, rightNode.left);
        boolean isSame = inside && outside;
        return isSame;
    }
}
```
## 方法二：迭代法

使用队列：
![img=gif](https://tva1.sinaimg.cn/large/008eGmZEly1gnwcimlj8lg30hm0bqnpd.gif)

> 注意：这里的迭代法并不是前中后序的迭代写法，因为本题的本质是判断两个树是否相互翻转。
>
> 这里使用队列来比较两个树（根节点的左右子树）是否相互翻转

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        //迭代法
        //使用队列，两两比较
        Queue<TreeNode> que = new LinkedList<>();
        que.add(root.left);
        que.add(root.right);
        while(!que.isEmpty()) {
            TreeNode left = que.poll();
            TreeNode right = que.poll();
            //左右节点都为空，说明是对称的
            if(left == null && right == null) {
                continue;
            }
            //左右节点只有一个为空，或者左右节点不想等，return false
            if(left == null || right == null || (left.val != right.val)) {
                return false;
            }
            que.add(left.left);   // 加入左节点左孩子
            que.add(right.right); // 加入右节点右孩子
            que.add(left.right);  // 加入左节点右孩子
            que.add(right.left);  // 加入右节点左孩子
        }
        return true;
    }
}
```
这里将队列改成用栈的方式也是一样的，只需要将队列原封不同的改成栈就可以了

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        //迭代法
        //使用栈，两两比较
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root.left);
        stack.push(root.right);
        while(!stack.isEmpty()) {
            TreeNode left = stack.pop();
            TreeNode right = stack.pop();

            //左右节点都为空，则继续
            if(left == null && right == null) {
                continue;
            }
            //左右节点只有一个为空，或者左右节点不想等，return false
            if(left == null || right == null || (left.val != right.val)) {
                return false;
            }
            //外侧
            stack.push(left.left);
            stack.push(right.right);
            //内侧
            stack.push(left.right);
            stack.push(right.left);
        }
        return true;
    }
}
```
# 3. 二叉树的最大深度

## 方法一：递归法

```java
class Solution {
    public int maxDepth(TreeNode root) {
        //深度优先搜索
        //递归：
        //1. 确定参数和返回值：root，返回值为深度，从底层开始往上层计数
        //2. 确定终止条件
        //3. 确定每层逻辑: 每层深度+1
        getMaxDepth(root);
        return getMaxDepth(root);
    }

    public int getMaxDepth(TreeNode root) {
        if(root == null) {
            return 0;
        }
        int leftDepth = getMaxDepth(root.left);
        int rightDepth = getMaxDepth(root.right);
        int depth = 1 + Math.max(leftDepth, rightDepth);
        return depth;
    }
}
```
## 方法二：层序遍历

```java
class Solution {
    public int maxDepth(TreeNode root) {
        //广度优先搜索：层序遍历
        //使用队列
        if(root == null) return 0;
        Queue<TreeNode> que = new LinkedList<>();
        que.add(root);
        int depth = 0;
        while(!que.isEmpty()) {
            int size = que.size();
            depth++;
            for(int i = 0; i < size; i++) {
                TreeNode node = que.poll();
                if(node.left != null) que.add(node.left);
                if(node.right != null) que.add(node.right);
            }
        }
        return depth;
    }
}
```

## 求n叉树的最大深度

和求二叉树的最大深度基本一致，稍微处理一下子树节点即可

### 递归法：后序遍历
```java
class Solution {
    public int maxDepth(Node root) {
        //递归法
        return getMaxDepth(root);
    }

    public int getMaxDepth(Node root) {
        if(root == null) return 0;

        int size = root.children.size();
        int depth = 0;
        for(int i = 0; i < size; i++) { //求children的最大深度
            depth = Math.max(depth, getMaxDepth(root.children.get(i)));
        }
        return 1 + depth;
    }
}
```
### 迭代法：层序遍历

```java
class Solution {
    public int maxDepth(Node root) {
        //层序遍历
        //使用队列，一层一层遍历，使用depth来记录遍历的层数
        if(root == null) return 0;
        Queue<Node> que = new LinkedList<>();
        que.add(root);
        int depth = 0;
        while(!que.isEmpty()) {
            int size = que.size();
            depth++;
            for(int i = 0; i < size; i++) {
                Node node = que.poll();
                int childrenSize = node.children.size();
                for(int j = 0; j < childrenSize; j++) { //将孩子节点入队列
                    if(node.children.get(j) != null) que.add(node.children.get(j));
                }
            }
        }
        return depth;
    }
}
```

# 4. 二叉树的最小深度

## 递归法：后序遍历

思路：

和求最大深度有一个点不太一样，需要注意左子树为空，右子树不为空的（或者右子树为空，左子树不为空）情况:如下

![img=png](https://img-blog.csdnimg.cn/20210203155800503.png)
```java
class Solution {
    public int minDepth(TreeNode root) {
        //深度优先搜索，递归法，后序遍历
        //1. 确定参数和返回值：参数为root，返回值为int
        //2. 确定终止条件
        //3. 确定每层逻辑，取最小值(需要注意节点只有一个子树为空的情况，因为叶子节点是指没有子节点的节点)
            //左子节点为空，右子节点不为空的情况
            //右子节点为空，左子节点不为空的情况
            //左右节点都不为空的情况

        return getMinDepth(root);
    }

    public int getMinDepth(TreeNode root) {
        if(root == null) {
            return 0;
        }

        int leftDepth = getMinDepth(root.left);
        int rightDepth = getMinDepth(root.right);

        if(root.left == null && root.right != null) {
            return 1 + rightDepth;
        }
        if(root.right == null && root.left != null) {
            return 1 + leftDepth;
        }
        return 1 + Math.min(leftDepth, rightDepth);
    }
}
```
## 迭代法

```java
class Solution {
    public int minDepth(TreeNode root) {
        //广度优先搜索，层序遍历
        //使用队列
        //只有在左右孩子同时为0时，才是最小深度
        if(root == null) return 0;
        Queue<TreeNode> que = new LinkedList<>();
        que.add(root);
        int depth = 0;
        while(!que.isEmpty()) {
            int size = que.size();
            depth++;
            for(int i = 0;i < size;i++) {
                TreeNode node = que.poll();
                if(node.left == null && node.right == null) {
                    return depth;
                }
                if(node.left != null) que.add(node.left);
                if(node.right != null) que.add(node.right);
            }
        }
        return depth;
    }
}
```

# 5. 完全二叉树的节点个数

## 迭代法：层序遍历

```java
class Solution {
    public int countNodes(TreeNode root) {
        //使用层序遍历
        //队列
        //统计结点数
        if(root == null) return 0;
        Queue<TreeNode> que = new LinkedList<>();
        que.add(root);
        int count = 0;
        while(!que.isEmpty()) {
            int size = que.size();
            for(int i = 0; i < size; i++) {
                count++;
                TreeNode node = que.poll();
                if(node.left != null) que.add(node.left);
                if(node.right != null) que.add(node.right);
            }
        }
        return count;
    }
}
```

## 递归法：后序遍历

```java
class Solution {
    public int countNodes(TreeNode root) {
        //递归法，后序遍历
        //1. 确定参数和返回值
        //2. 确定终止条件
        //3. 确定单层递归的逻辑
        return getCountNodes(root);
    }

    public int getCountNodes(TreeNode root) {
        if(root == null) return 0;

        int leftCount = getCountNodes(root.left);   //左子树节点
        int rightCount = getCountNodes(root.right); //右子树节点
        int sum = 1 + leftCount + rightCount;       //+1代表中间节点
        return sum;
    }
}
```

# 6. 平衡二叉树
[leetcode](https://leetcode-cn.com/problems/balanced-binary-tree/)
思路：递归，后序遍历


```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        //递归法
        //1. 确定参数和返回值，返回值是子树的高度int，如果不是平衡二叉树，则返回-1
        //2. 确定终止条件
        //3. 确定单层递归逻辑: 
            //判断左右子树的返回值是否为-1，如果是的话则继续返回-1
            //判断左子树和右子树的高度差不超过1
        if(getDepth(root) == -1) {
            return false;
        } else {
            return true;
        }
    }

    public int getDepth(TreeNode root) {
        if(root == null) return 0;

        int left = getDepth(root.left);   //左
        if(left == -1) return -1;
        int right = getDepth(root.right); //右  
        if(right == -1) return -1;
        
        if(Math.abs(left - right) > 1) {  //中
            return -1;
        } else {
            return 1 + Math.max(left, right);
        }
    }
}
```

# 7. 二叉树的所有路径

[leetcode](https://leetcode-cn.com/problems/binary-tree-paths/)

思路：递归，回溯

```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        //递归法:前序遍历，使用回溯
        //1. 确定返回值和参数：list为结果集，使用path来记录每一条路径
        //2. 确定终止条件：当该节点没有左右子节点时终结
        //3. 确定单层逻辑：回溯
            //回溯
        List<String> list = new LinkedList<>();
        if(root == null) {
            return list;
        }
        List<Integer> path = new LinkedList<>();
        getPath(root, list, path);
        return list;
    } 

    public void getPath(TreeNode root, List<String> list, List<Integer> path) {
        path.add(root.val);                 //中
        if(root.left == null && root.right == null) {
            String s = "";
            int size = path.size();
            for(int i = 0; i < size - 1; i++) {
                s = s + Integer.toString(path.get(i));
                s = s + "->";
            }
            s = s + Integer.toString(path.get(size - 1));
            list.add(s);
        }

        
        if(root.left != null) {
            getPath(root.left, list, path); //左
            path.remove(path.size() - 1); //回溯
        }
        if(root.right != null) {
            getPath(root.right, list, path); //右
            path.remove(path.size() - 1); //回溯
        }
    }
}
```

# 8. 左叶子之和

注意：不是通过节点的左右孩子判断本节点的属性，而是需要通过本节点的父节点来判断本节点的属性。

## 递归法：后序遍历

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        //递归法，深度优先搜索：后序遍历
        //1. 确定参数和返回值
        //2. 确定递归终止条件
        //3. 确定单次递归逻辑

        return getLeftCount(root);
    }

    public int getLeftCount(TreeNode root){
        if(root == null) return 0;

        int leftCount = getLeftCount(root.left);
        int rightCount = getLeftCount(root.right);

        int midValue = 0;
        if(root.left != null && root.left.left == null && root.left.right == null) {
            midValue = root.left.val;
        }

        return midValue + leftCount + rightCount;
    }
}
```

## 迭代法：前序遍历

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        //迭代法：前序遍历
        //使用队列
        if(root == null) return 0;
        Queue<TreeNode> que = new LinkedList<>();
        que.add(root);
        int countLeftLeaves = 0;
        while(!que.isEmpty()) {
            TreeNode node = que.poll();
            if(node.left != null && node.left.left == null && node.left.right == null) { //通过父节点判断其是否有左孩子
                countLeftLeaves += node.left.val;
            }
            if(node.left != null) que.add(node.left);
            if(node.right != null) que.add(node.right);
        }
        return countLeftLeaves;
    }   
}
```

# 9. 找树左下角的值

## 递归法

```java
class Solution {
    private int maxDepth;
    private int maxLeftValue;
    public int findBottomLeftValue(TreeNode root) {
        //递归法：前序遍历，找深度，回溯
        //1. 使用找树的最大深度来遍历，当遇到叶子节点时，判断其深度，如果深度大于已有的树，则更新值
            //1. 确定参数和返回值
            //2. 确定终止条件
            //3. 确定单层递归逻辑
        if(root == null) return 0;
        getDepth(root, 1);
        return maxLeftValue;

    }

    public void getDepth(TreeNode root, int depth){
        if(root.left == null && root.right == null){
            if(depth > maxDepth) {
                maxDepth = depth;
                maxLeftValue = root.val;        //中
            }
            return;
        }

        if(root.left != null) {
            depth++;
            getDepth(root.left, depth);         //左
            depth--;
        }

        if(root.right != null) {
            depth++;
            getDepth(root.right, depth);        //右
            depth--;
        }
    }
}
```

## 迭代法
```java
class Solution {
    private int maxLeftValue;
    public int findBottomLeftValue(TreeNode root) {
        //迭代法
        //保存每一层的第一个值，直到最后一层
        if(root == null) return 0;
        Queue<TreeNode> que = new LinkedList<>();
        que.add(root);
        while(!que.isEmpty()) {
            int size = que.size();
            TreeNode temp = que.poll();
            maxLeftValue = temp.val; //取每层的第一个值
            if(temp.left != null) que.add(temp.left);
            if(temp.right != null) que.add(temp.right);
            for(int i = 1; i < size; i++) { //从1开始
                temp = que.poll();
                if(temp.left != null) que.add(temp.left);
                if(temp.right != null) que.add(temp.right);
            }
        }
        return maxLeftValue;
    }
}
```

# 10. 路径总和
[leetcode](https://leetcode-cn.com/problems/path-sum/)
## 递归法
```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        //迭代法：前序遍历，回溯法
        //确认参数和返回值
        //确定终止条件
        //确定单层逻辑
        if(root == null) {
            return false;
        }
        return getPathSum(root, targetSum, 0);
    }

    public boolean getPathSum(TreeNode root, int targetSum, int pathSum) {
        if(root.left == null && root.right == null) { //注意这里一定要判断是否为叶子节点
            pathSum += root.val;
            if(pathSum == targetSum) {
                return true;
            }
            return false;
        }
        boolean left = false;
        boolean right = false;
        if(root.left != null) {
            pathSum += root.val;
            left= getPathSum(root.left, targetSum, pathSum);
            pathSum -= root.val;
        }
        if(root.right != null) {
            pathSum += root.val;
            right = getPathSum(root.right, targetSum, pathSum);
            pathSum -= root.val;
        }
        
        return (left || right);
    }
}
```
## 迭代法

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        //迭代法，先序遍历，使用栈
        if(root == null) {
            return false;
        }
        Deque<TreeNode> stack1 = new LinkedList<>();
        Deque<Integer> stack2 = new LinkedList<>();
        stack1.push(root);stack2.push(root.val);
        while(!stack1.isEmpty()) {
            int size = stack1.size();
            for(int i = 0; i < size; i++) {
                TreeNode temp = stack1.pop();
                int value = stack2.pop();
                if(temp.left == null && temp.right == null) {//判断叶子节点
                    if(value == targetSum) {
                        return true;
                    }
                }
                if(temp.right != null) {
                    stack1.push(temp.right);
                    stack2.push(value + temp.right.val);
                }
                if(temp.left != null) {
                    stack1.push(temp.left);
                    stack2.push(value + temp.left.val);
                }
            }
        }
        return false;
    }
}
```

# 11. 路径总和II

```java
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        //递归法，先序遍历
        List<List<Integer>> pathList = new LinkedList<>();
        if(root == null) {
            return pathList;
        }
        List<Integer> path = new LinkedList<>();
        getPath(root, targetSum, pathList, path);
        return pathList; 
    }

    public void getPath(TreeNode root, int count, List<List<Integer>> pathList, List<Integer> path) {
        path.add(root.val);
        if(root.left == null && root.right == null) {
            count -= root.val;
            if(count == 0) {
                pathList.add(new LinkedList<>(path));//这个地方要注意，必须new一个LinkedList，不然传入的是原来的引用，数值会改变
                return;
            }
        }
        if(root.left != null) {
            getPath(root.left, count - root.val, pathList, path);
            path.remove(path.size() - 1);
        }

        if(root.right != null) {
            getPath(root.right, count - root.val, pathList, path);
            path.remove(path.size() - 1);
        }
    }
}
```

# 12. 从中序和后序遍历构造二叉树

[leetcode](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

思路：迭代法

> 注意：
> 1. 给左右子树赋值的时候，传递的后序和中序数组的起止点，都遵循左闭右开原则
> - 中序左子树：[inLeft, rootIndex) 右子树 [rootIndex + 1，inRight)
> 这里去掉了 rootIndex 这个值
> - 后序左子树：[postLeft, postLeft + rootIndex - inLeft) 右子树 [postLeft + rootIndex - inLeft, postRight - 1)
> 这里去掉了 postRight 这个值
后序的左右子树是根据中序的左右子树的长度确定的


```java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        //递归法：根据后序数组的最后一个元素分割中序数组，再根据分割后中序数组的左子树和右子树分割后序数组
        //1. 确定参数和返回值：中序数组、后序数组、相应的分割序号; 返回值是根节点
        //2. 确定终止条件：数组的大小为0
        //3. 确定单层递归逻辑：
            //1. 根据后序数组的最后一个元素给根节点赋值、分割中序数组
            //2. 根据分割后的中序数组分割后序数组
            //3. 递归给根节点的左子树和右子树赋值
        return traversal(inorder, 0, inorder.length, postorder, 0, postorder.length);
    }

    public TreeNode traversal(int[] inorder, int inLeft, int inRight,
                                int[] postorder, int postLeft, int postRight) {
        if(postRight - postLeft < 1) return null;
        if(postRight - postLeft == 1) return new TreeNode(postorder[postLeft]);
        int rootVal = postorder[postRight - 1];
        TreeNode root = new TreeNode(rootVal);

        //分割中序数组
        int rootIndex = 0;
        for(int i = inLeft; i < inRight; i++) {
            if(inorder[i] == rootVal) {
                rootIndex = i; 
                break;
            }
        }   

        //左右子树赋值
        root.left = traversal(inorder, inLeft, rootIndex, postorder, postLeft, (postLeft + rootIndex - inLeft));
        root.right = traversal(inorder, rootIndex + 1, inRight, postorder, (postLeft + rootIndex - inLeft), postRight - 1);

        return root;
    }
}
```

# 13. 从前序和中序遍历构造二叉树

思路：迭代法

根据前序的开头元素分割中序数组
> 注意给左右子树赋值的时候，前序数组要去掉preLeft这个值，需要传入 preLeft + 1

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        //递归法：根据前序的开头元素分割中序数组
        //1. 确定参数和返回值
        //2. 确定终止条件
        //3. 确定单层逻辑
        return traversal(preorder, 0, preorder.length, inorder, 0, inorder.length);
    }

    public TreeNode traversal(int[] preorder, int preLeft, int preRight, int[] inorder, int inLeft, int inRight) {
        if(preRight - preLeft == 1) {
            return new TreeNode(preorder[preLeft]);
        }
        if(preRight - preLeft < 1) {
            return null;
        }
        int rootVal = preorder[preLeft];
        TreeNode root = new TreeNode(rootVal);
        //分割中序数组
        int rootIndex = 0;
        for(int i = inLeft; i < inRight; i++) {
            if(inorder[i] == rootVal) {
                rootIndex = i;
                break;
            }
        }

        //左右子树赋值
        root.left = traversal(preorder, preLeft + 1, preLeft + 1 + (rootIndex - inLeft), inorder, inLeft, rootIndex);
        root.right = traversal(preorder, preLeft + 1 + (rootIndex - inLeft), preRight, inorder, rootIndex + 1, inRight);

        return root;
    }
}
```

# 13. 最大二叉树

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        //递归法
        //1. 确定参数和返回值
        //2. 确定递归终止条件
        //3. 确定单层递归逻辑
        return traversal(nums, 0, nums.length);
    }

    public TreeNode traversal(int[] nums, int left, int right) {
        if(right - left < 1) return null;
        //if(right - left == 1) return new TreeNode(nums[left]);这一句可有可无

        //找最大值
        int max = nums[left];
        int maxIndex = left;
        for(int i = left; i < right; i++) {
            if(nums[i] > max) {
                max = nums[i];
                maxIndex = i;
            }
        }
        TreeNode root = new TreeNode(max);

        //给左右子树赋值
        root.left = traversal(nums, left, maxIndex);
        root.right = traversal(nums, maxIndex + 1, right);

        return root;
    }
}
```

# 14. 合并二叉树

## 方法一：递归法

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        //递归法，先序遍历
        //1. 确定参数和返回值
        //2. 确定递归终止条件
        //3. 确定单层递归逻辑

        return traversal(root1, root2);

    }

    public TreeNode traversal(TreeNode root1, TreeNode root2) {
        if(root1 == null) return root2;
        if(root2 == null) return root1;

        TreeNode root = new TreeNode(root1.val + root2.val);

        root.left = traversal(root1.left, root2.left);
        root.right = traversal(root1.right, root2.right);

        return root;
    }
}
```

## 方法二：迭代法
```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        //迭代法
        //队列，使用左节点来存储
        if(root1 == null) return root2;
        if(root2 == null) return root1;
        Queue<TreeNode> que = new LinkedList<>();

        que.add(root1);
        que.add(root2);
        while(!que.isEmpty()) {
            TreeNode node1 = que.poll();
            TreeNode node2 = que.poll();
            
            node1.val += node2.val;

            if(node1.left != null && node2.left != null) {
                que.add(node1.left);
                que.add(node2.left);
            }
            if(node1.right != null && node2.right != null) {
                que.add(node1.right);
                que.add(node2.right);
            }
            //root1左子树为空，将root2的赋值给root1
            if(node1.left == null && node2.left != null) {
                node1.left = node2.left;
            }
            //root1右子树为空，将root2的赋值给root1
            if(node1.right == null && node2.right != null) {
                node1.right = node2.right;
            }
            //不需要考虑root1左右节点不为空，root2为空的情况，因为最后返回的就是root1
        }
        return root1;
    }
}
```

# 15. 二叉搜索树中的搜索

## 方法一：递归
思路：
1. 这个地方需要加上返回值TreeNode

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        //二叉搜索树
        //迭代法，左边和右边
        return getNode(root, val);
    }

    public TreeNode getNode(TreeNode root, int val) {
        if(root == null) return null;

        if(root.val == val) return root;

        if(root.val > val) {
            return getNode(root.left, val);
        }

        if(root.val < val) {
            return getNode(root.right, val);
        }
        return null;
    }
}
```

## 方法二：迭代，普通二叉树
注意：这个方法会超时，看下一种不需要栈的方法
```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        //二叉搜索树，迭代法
        if(root == null) return null;
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        while(!stack.isEmpty()) { //迭代法前序遍历
            TreeNode node = stack.pop();
            if(node.val == val) return node; //中
            if(node.val > val && node.left != null) stack.push(root.left); //左
            if(node.val < val && node.right != null) stack.push(root.right); //右
        }
        return null;
    }       
}
```
## 方法三：迭代，利用二叉搜索树的特点

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        //二叉搜索树，迭代法
        while(root != null) {
            if(root.val == val) {
                return root;
            }
            if(root.val > val) {
                root = root.left;
            } else {
                root = root.right;
            }
        }
        return null;
    }       
}
```

# 15. 验证二叉搜索树

## 递归将二叉搜索树转换为有序数组

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        //递归法：二叉搜索树的中序遍历是一个有序数组
        //通过中序遍历存入数组中，最后判断数组是否是有序的
        //1. 确定返回值和参数
        //2. 确定递归终止条件
        //3. 确定单层逻辑
        List<Integer> list = new ArrayList<>();
        getInorderList(root, list);
        return isValid(list);
    }

    public void getInorderList(TreeNode root, List<Integer> list) {
        if(root == null) return;
        getInorderList(root.left, list); //左
        list.add(root.val); //中
        getInorderList(root.right, list);//右
        
    }

    public boolean isValid(List<Integer> list) {
        for(int i = 1; i < list.size(); i++) {
            if(list.get(i) <= list.get(i-1)){
                return false;
            }
        }
        return true;
    }
}
```

## 直接递归

```java
class Solution {
    
    Integer max;

    public boolean isValidBST(TreeNode root) {
        //递归法：
        //max是前一个节点的值
        //1. 确定返回值和参数
        //2. 确定递归终止条件
        //3. 确定单层逻辑
        if(root == null) return true;
        boolean left = isValidBST(root.left);
        if(max != null && root.val <= max) {//max是前一个节点的值，前一个节点与中间节点进行比较
            return false;
        } 
        max = root.val;
        boolean right = isValidBST(root.right);

        return left && right;
    }
}
```

## 迭代法
思路：
1. 先写出中序遍历
2. 再此基础上进行修改


```java
class Solution {
    
    Integer max;

    public boolean isValidBST(TreeNode root) {
        //迭代法：中序遍历
        //1. 使用栈
        //2. 入栈为先入左边，直到左边节点为空时，开始处理元素，然后再右边入栈
        Deque<TreeNode> stack = new LinkedList<>();
        List<Integer> list = new ArrayList<>();
        TreeNode curr = root;
        while(curr != null || !stack.isEmpty()) {
            if(curr != null) {
                stack.push(curr);   
                curr = curr.left;
            } else {
                curr = stack.pop(); 
                if(max != null && curr.val <= max) {
                    return false;
                } else {
                    max = curr.val;
                }
                curr = curr.right;  
            }
        }
        return true;
    }
}
```

# 16. 二叉搜索树的最小绝对差

## 递归转换成有序数组

思路：
1. 将二叉搜索树转换成有序的数组

```java
class Solution {

    Integer min;

    public int getMinimumDifference(TreeNode root) {
        //二叉搜索树
        //中序遍历二叉搜索树，将二叉搜索树转换为数组
        List<Integer> list = new ArrayList<>();
        traversal(root, list);
        //遍历数组list
        int min = Integer.MAX_VALUE;
        for(int i = 1; i < list.size(); i++) {
            if(list.get(i) - list.get(i-1) < min) {
                min = list.get(i) - list.get(i-1);
            }
        }
        return min;
    }

    public void traversal(TreeNode root, List<Integer> list) {
        if(root == null) return;
        traversal(root.left, list);
        list.add(root.val);
        traversal(root.right, list);
    }
}
```

## 直接使用递归
思路：

pre指向上一个节点，root指向当前节点。
如果理解不了的话建议画出pre和curr指针来理解

```java
class Solution {

    TreeNode pre;//记录上一个遍历的节点
    int result = Integer.MAX_VALUE;

    public int getMinimumDifference(TreeNode root) {
        //递归法，中序遍历
        traversal(root);
        return result;
    }

    public void traversal(TreeNode root) {
        if(root == null) return;
        //左
        traversal(root.left);   
        if(pre != null) {
            result = Math.min(result, root.val - pre.val);//中
        }
        pre = root;
        //右
        traversal(root.right);
    }
}
```

# 17. 二叉搜索树中的众数

思路：
1. 使用pre节点，当pre和当前节点相等时，count自增
2. 使用resList记录众数，如果count > maxCount则需要清空resList中的值
3. 

```java
class Solution {
    ArrayList<Integer> resList = new ArrayList<>();
    int count = 0;
    int maxCount = 0;
    TreeNode pre = null;

    public int[] findMode(TreeNode root) {
        //递归遍历，得到众数
        //中序遍历，比较前一个节点和当前节点
        findMode1(root);
        int[] res = new int[resList.size()];
        for(int i = 0; i < resList.size(); i++) {
            res[i] = resList.get(i);
        }
        return res;
    }
    
    public void findMode1(TreeNode root) {
        if (root == null) {
            return;
        }
        findMode1(root.left);       //左

        int rootValue = root.val;   //中

        //计数
        if(pre == null || rootValue != pre.val) {
            count = 1;
        } else {
            count++;
        }
        //更新结果以及maxCount
        if(count > maxCount) {
            resList.clear();
            resList.add(rootValue);
            maxCount = count;
        } else if (count == maxCount) {
            resList.add(rootValue);
        }
        pre = root;

        findMode1(root.right);      //右
    }
}
```

# 18. 二叉树的最近公共祖先

![image.png](https://note.youdao.com/yws/res/12906/WEBRESOURCEbb51601897b41cb55f4a7aa427681aed)

思路：
1. 递归：后序遍历
2. 参数和返回值：参数为root、节点p、q，返回值为找到的p或者q节点，如果为null，则表示没有找到
3. 确定终止条件：遇到p、q节点则立即返回
4. 确定单层递归逻辑：如果左右都不为null，则当前节点为公共祖先，如果左边为null，则返回右边，右边为null，则返回左边

特别的情况，如果5和4为p、q，则遍历到5的时候就返回了

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //递归，后序遍历，如果左子树有该节点，右子树也有该节点，则该节点成立
        return getTreeNode(root, p, q);
    }

    public TreeNode getTreeNode(TreeNode root, TreeNode p, TreeNode q) {
        if(root == q || root == p || root == null) return root; //囊括了第二种情况
        TreeNode left = getTreeNode(root.left, p, q);    //左
        TreeNode right = getTreeNode(root.right, p, q);   //右
        if(left != null && right != null) return root;
        
        if(left == null && right != null) return right;
        
        if(right == null && left != null) return left;

        return null;
    }
}
```

# 19. 二叉树的插入操作
[leetcode](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

## 递归法

思路：
1. 与遍历的节点进行比较，如果大于该节点并且该节点的右子节点为空，则赋给该右子节点
2. 如果小于该节点并且该节点的左子节点为空，则赋给该左子节点

```java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        //递归法
        //1. 确定参数和返回值
        //2. 确定递归终止条件
        //3. 确定单层递归条件
        if(root == null) return new TreeNode(val);
        traversal(root, val);
        return root;
    }

    public void traversal(TreeNode root, int val) {
        if(root.val < val) {
            if(root.right == null) {
                root.right = new TreeNode(val);
                return;
            } else {
                traversal(root.right, val);
            }
        }
        if(root.val > val) {
            if(root.left == null) {
                root.left = new TreeNode(val);
                return;
            } else {
                traversal(root.left, val);
            }
        }
    }
}
```

## 迭代法

```java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        //迭代法
        //如何进行迭代操作呢？
        //while循环遍历
        if(root == null) {
            return new TreeNode(val);
        }

        TreeNode curr = root;
        TreeNode parent = root;
        while(curr != null) {
            parent = curr;
            if(curr.val > val) {
                curr = curr.left;
            } else {
                curr = curr.right;
            }
        }
        TreeNode node = new TreeNode(val);
        if(val < parent.val) parent.left = node;
        else parent.right = node;
        return root;
    }
}
```

# 20. 修剪二叉搜索树

思路：
递归法：
1. 如果当前节点不在区间[low, high]中，则找其左右节点满足条件的节点返回
2. 删除当前节点的操作：拼接父节点和子节点

```java
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        //递归法
        //思路：将不符合的节点去除，去除的方法拼接该节点的父节点和子节点
        //1. 确定参数和返回值
        //2. 确定终止条件
        //3. 确定单层递归逻辑
        if(root == null) return null;
        if(root.val < low) {
            TreeNode node = trimBST(root.right, low, high);
            return node;
        }
        if(root.val > high) {
            TreeNode node = trimBST(root.left, low, high);
            return node;
        }
        root.left = trimBST(root.left, low, high);
        root.right = trimBST(root.right, low, high);
        return root;
    }
}
```

# 21. 将有序数组转换为二叉搜索树
[leetcode](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        //构造二叉搜索树
        //先找中间的值，分割成左右子树，再递归遍历左右子树
        //1. 确定参数和返回值
        //2. 确定终止条件
        //3. 确定单层递归逻辑
        
        return constructSearchTree(nums, 0, nums.length - 1);
    }

    public TreeNode constructSearchTree(int[] nums, int start, int end) {
        if(start > end) return null;

        int mid = (start + end) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = constructSearchTree(nums, start, mid - 1);
        root.right = constructSearchTree(nums, mid + 1, end);
        return root;
    }
}
```

# 22. 


```java
class Solution {
    int pre = 0;
    public TreeNode convertBST(TreeNode root) {
        //递归法 
        //思路： 反中序遍历，右中左
        //1. 确定参数和返回值
        //2. 确定递归终止条件
        //3. 确定单层逻辑
        traversal(root);
        return root;
    }

    public void traversal(TreeNode curr) {
        if(curr == null) return;
        traversal(curr.right);
        curr.val = curr.val + pre;
        pre = curr.val;
        traversal(curr.left);
    }
}
```
