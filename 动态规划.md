# 动态规划
## 理论基础
[理论基础](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)

dp五部曲：
1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 1. 斐波那契数

简单题目用来搞懂动态规划的五部曲：
1. 确定dp数组以及下标的含义
dp[i]的定义为：第i个数的斐波那契数值是dp[i]
2. 确定递推公式
题目已经直接给了：dp[i] = dp[i - 1] + dp[i - 2];
3. dp数组如何初始化
题目也给了dp[0] = 0, dp[1] = 1;
4. 确定遍历顺序
从递归公式dp[i] = dp[i - 1] + dp[i - 2]可以看出，dp[i] 是依赖 dp[i-1] 和 dp[i-2]的，那么遍历顺序就是从前向后遍历
5. 举例推导dp数组
例如n=10时，dp数组应该为：0 1 1 2 3 5 8 13 21 34 55，如果代码写出来结果不对，则把dp数组打印出来看看和我们推导的数列是不是一致


### 方法一
```java
class Solution {
    public int fib(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;

        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

### 方法二：数组只需要两个元素即可

```java
class Solution {
    public int fib(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;

        // 只需要维护两个元素即可
        int[] dp = new int[2];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            int sum = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = sum;
        }
        return dp[1];
    }
}
```

## 2. 爬楼梯



```java
class Solution {
    public int climbStairs(int n) {
        // 动态规划
        // 1. 确定dp数组以及下标的含义：dp[i]是爬到i层楼梯的方法
        // 2. 确定递推公式：dp[i-1]跨1步可以到dp[i]，dp[i-2]跨2个台阶可以到达dp[i]，因为到达第i层的方法数dp[i] = dp[i-1] + dp[i-2]
        // 3. dp数组如何初始化：不需要考虑dp[0]，dp[1]=1, dp[2]=2;
        // 4. 确定遍历顺序：从前往后遍历
        // 5. 举例推导dp数组

        if (n <= 2) return n;

        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;

        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2]; 
        }

        return dp[n];

    }
}
```

思考：如果一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法可以爬到楼顶，这个时候就需要dp[i] = dp[i-1] + dp[i-2] + ... + dp[i-m];

```java
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) { // 把m换成2，就可以AC爬楼梯这道题
        if (i - j >= 0) dp[i] += dp[i - j];
    }
}
```


## 3. 使用最小花费爬楼梯

思路：
1. 确定dp数组和下标：dp[i]是到达第i个台阶所花费的最少体力，包括自己的这一层的花费
2. 确定递推公式：dp[i]可以通过dp[i-1]和dp[i-2]获得，这里选最小的dp[i] = min(dp[i-1], dp[i-2]) + cost[i]，注意这里是cost[i], 表示到该层再往上的花费
3. dp数组的初始化：dp[0] = cost[0], dp[1] = cost[1]
4. 确定遍历顺序：从前往后遍历
5. 举例推导dp数组: 如果代码结果不对的话 
6. 注意最后一步：最后一步，如果是由倒数第二步爬，则最后一步的体力花费可以不用算

```
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        // 动态规划
        // 1. 确定dp数组和下标：dp[i]是到达第i个台阶所花费的最少体力，包括自己的这一层的花费
        // 2. 确定递推公式：dp[i]可以通过dp[i-1]和dp[i-2]获得，这里选最小的dp[i] = min(dp[i-1], dp[i-2]) + cost[i]，注意这里是cost[i], 表示到该层再往上的花费
        // 3. dp数组的初始化：dp[0] = cost[0], dp[1] = cost[1]
        // 4. 确定遍历顺序：从前往后遍历
        // 5. 举例推导dp数组: 如果代码结果不对的话
        
        if (cost == null || cost.length == 0) return 0;
        if (cost.length == 1) return cost[0];

        int[] dp = new int[cost.length];
        dp[0] = cost[0];
        dp[1] = cost[1];

        for (int i = 2; i < cost.length; i++) {
            dp[i] = Math.min(dp[i-1], dp[i-2]) + cost[i];
        }

        //最后一步，如果是由倒数第二步爬，则最后一步的体力花费可以不用算
        return Math.min(dp[cost.length - 1], dp[cost.length-2]);
    }
}
```

## 4. 不同路径

![image](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

```java
class Solution {
    public int uniquePaths(int m, int n) {
        // 1. 确定dp数组以及下标：dp[i][j] 表示到（i,j）有多少条路径
        // 2. 确定dp数组的递推公式：其从左边过来或者从上边过来，则 dp[i][j] = dp[i-1][j] + dp[i][j-1];
        // 3. 确定dp数组的初始化值：其最上方和最左方的值一定为1: dp[0][i] = 0; dp[i][0] = 0;
        // 4. 确定dp数组的遍历顺序：一层一层从左到右遍历可以保证其上方和左方一定有数值
        // 5. 如果ac不了，打印数组来对比

        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int i = 0; i < n; i++) dp[0][i] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```

## 5. 不同路径II

思路：
- 增加了障碍物
- 在有障碍物的地方保持0即可

![image](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        // 1. 确定dp数组下标：dp[i][j] 表示到（i，j）有多少条路径
        // 2. 确定dp数组的推导：dp[i][j] = dp[i-1][j] + dp[i][j-1]
        // 3. 确定dp数组的初始化：有障碍的地方保持0即可，最左边和最右边初始化为1，但是如果遇到障碍，障碍左边和障碍下边初始化为0
        // 4. 确定dp数组的遍历顺序，一层一层从左到右，有障碍的地方保持0即可
        // 5. 打印..

        int x = obstacleGrid.length;
        int y = obstacleGrid[0].length;
        int[][] dp = new int[x][y];

        for (int i = 0; i < x; i++) {
            if (obstacleGrid[i][0] == 1) break; //一旦遇到障碍，后续都到不了
            dp[i][0] = 1;
        }
        for (int i = 0; i < y; i++) {
            if (obstacleGrid[0][i] == 1) break; //一旦遇到障碍，后续都到不了
            dp[0][i] = 1;
        }
        for (int i = 1; i < x; i++) {
            for (int j = 1; j < y; j++) {
                if (obstacleGrid[i][j] == 1) continue; // 有障碍物的地方，保持0
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[x-1][y-1];
    }
}
```

## 6. 整数拆分

思路：
1. dp[i]表示i的最大乘积
2. 设定 j 从 1 到 i-1，则取遍历过程中的最大值：dp[i] = max(dp[i], j * (i - j), j * dp[i - j])，其中j * (i - j)表示把 dp 分成两个数相乘，j * dp[i - j] 表示把 dp 分解成两个数以上相乘。为什么要加上dp[i]则是在遍历j的过程中取最大值。

```java
class Solution {
    public int integerBreak(int n) {
        // 1. dp数组定义和下标：dp[i]表示i的最大乘积
        // 2. dp数组的递推：j从1开始，dp[i] = max(dp[i], j*(i-j), j*dp[i-j])
        // 3. dp数组的初始化：从2开始：dp[2] = 1
        // 4. dp数组的初始化顺序
        // 5. 打印..

        int[] dp = new int[n + 1];
        dp[2] = 1;
        for (int i = 3; i <= n; i++) {
            for (int j = 1; j < i - 1; j++) {
                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
            }
        }
        return dp[n];
    }
}
```

## 7. 不同的二叉搜索树

思路：
1. 先确定树为二叉搜索树，左子节点比父节点小，右子节点比父节点大
2.  dp[i]: 1到i为节点组成的二叉搜索树的个数为dp[i]。
3. 递推公式：dp[i] += dp[j-1] * dp[i-j] dp[j-1]为左节点，dp[i-j]为右节点个数，j的范围从1~i

```java
class Solution {
    public int numTrees(int n) {
        // 确定dp[i]的含义和下标： 1到i为节点组成的二叉搜索树的个数为dp[i]。
        // 确定dp数组的递推公式：dp[i] += dp[j-1] * dp[j-i]
        // 确定初始化顺序：dp[0] = 1
        // 确定遍历顺序：从前往后
        // 打印
        
        int[] dp = new int[n+1];
        dp[0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                //对于第i个节点，需要考虑1作为根节点直到i作为根节点的情况，所以需要累加
                //一共i个节点，对于根节点j时,左子树的节点个数为j-1，右子树的节点个数为i-j
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }

        return dp[n];
    }
}
```

## 01背包理论
几种背包的分类：只需要掌握01背包即可
![image](https://img-blog.csdnimg.cn/20210117171307407.png)
有n件物品和一个最多能背重量为w的背包。第i件物品的重量是weight[i]，得到的价值是value[i]。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。



## 8. 分割等和子集

思路：
1. 使用01背包，设定背包容量为sum/2
2. 当背包容量sum/2时其最大重量dp[sum/2] == sum/2时，则表示可以分割

```java
class Solution {
    public boolean canPartition(int[] nums) {
        // 01背包
        // 背包的体积为sum / 2
        // dp[j] = Math.max(dp[j], dp[j-nums[i]] + nums[i]);

        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
        }

        if(sum%2 != 0) return false;
        int[] dp = new int[sum/2 + 1];

        for (int i = 0; i < nums.length; i++) {
            for (int j = sum / 2; j >= nums[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j-nums[i]] + nums[i]);
            }
        }

        return dp[sum / 2] == sum / 2;
    }
}
```

## 9. 最后一块石头的重量II

```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        // 题目关键：将石头尽量分成相等的两堆，两者粉碎剩余数量最小
        // 上述描述可以等价为01背包问题：背包容量为所有石头重量一半，其最多能装多少石头
        // 只不过石头的重量和价值都是stones[i]
        // 1. 确定 dp数组下标和含义dp[j]表示重量为j的背包最多能装的石头重量
        // 2. 确定递推公式 dp[i] = max(dp[i], dp[i - weight[i]] + value[i])
        // 3. 初始化dp数组 dp[j] = 0
        // 4. 确定遍历顺序：从后往前
        // 5. 打印dp数组
        int target = 0;
        for (int i = 0; i < stones.length; i++) {
            target += stones[i];
        }
        int[] dp = new int[target / 2 + 1];
        for (int i = 0; i < stones.length; i++) {
            for (int j = target / 2; j >= stones[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return target - 2 * dp[target / 2]; 
    }
}
```

## 10. 目标和

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        // 根据公式可以推导出 bagSize = (target+sum)/2 
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
        }
        if ((target + sum) % 2 != 0) return 0;
        int bagSize = (target + sum) / 2;
        if (bagSize < 0) bagSize = -bagSize;

        //确定递归数组
        int[] dp = new int[bagSize + 1];

        //初始化
        dp[0] = 1;

        for (int i = 0; i < nums.length; i++) {
            for (int j = bagSize; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[bagSize];
    }
}
```

## 11. 一和零

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        // 背包大小bagsize m, n
        //1. 确定dp数组下标和含义：dp[i][j] 表示最多有i个0和j个1的最大子集长度
        //2. 确定dp数组的递推公式：oneNum,和zeroNum 表示当前遍历物品的0和1的个数
            // dp[i][j] = max(dp[i][j], dp[i-oneNum][j-oneNum] + 1)
        //3. 初始化为0
        //4. 遍历顺序，先遍历物品，再遍历二维背包
        int[][] dp = new int[m+1][n+1];
        for (String s : strs) {
            int oneNum = 0, zeroNum = 0;
            for (int index = 0; index < s.length(); index++) {
                if (s.charAt(index) == '0') {
                    zeroNum++;
                } else if (s.charAt(index) == '1') {
                    oneNum++;
                }
            }

            for (int i = m; i >= zeroNum; i--) {
                for (int j = n; j >= oneNum; j--) {
                    dp[i][j] = Math.max(dp[i][j], dp[i-zeroNum][j-oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
}
```

## 完全背包理论
将遍历背包容量的顺序变成从0到bagsize
并且先遍历物品还是先遍历背包都无所谓

但是如果求组合数的话就和遍历顺序有关系

## 12. 零钱兑换

```java
class Solution {
    public int change(int amount, int[] coins) {
        // 完全背包
        //1. dp[j]表示容量为j的背包能够放入的硬币的组合数
        //2. 递推公式 dp[j] += dp[j-coins[i]]
        int[] dp = new int[amount+1];
        //3. 初始化：dp[0] = 1
        dp[0] = 1;
        //4. 递推顺序：完全背包递推从前往后
        for (int i = 0; i < coins.length; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] += dp[j-coins[i]];
            }
        }
        return dp[amount];
    }
}
```

## 13. 组合总和IV

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        // 完全背包
        //1. 确定dp[j]的含义，dp[j]表示容量为j的背包凑成的排列个数
        //2. 确定dp[j]的递推公式，dp[j] += dp[j-nums[i]]
        //3. 初始化: dp[0] = 1
        //4. 确定遍历顺序: 排列问题，先遍历背包，再遍历物品
        int[] dp = new int[target+1];
        dp[0] = 1;
        for (int j = 0; j <= target; j++) {
            for (int i = 0; i < nums.length; i++) {
                if (j >= nums[i]) {
                    dp[j] += dp[j-nums[i]];
                }
            }
        }
        return dp[target];
    }
}
```

## 14. 完全平方数

```java
class Solution {
    public int numSquares(int n) {
        // 背包容量n，物品重量为i*i
        // 物品可以重复放入，完全背包
        // 1. 确定dp[j]下标和含义：j为背包容量，dp[j]为完全平方数的最少数量
        // 2. 确定递推公式，因为需要取最小值：dp[j] = min(dp[j-i*i] + 1, dp[j])
        int[] dp = new int[n+1];
        // 3. 初始化dp[0] = 0, 因为递推公式取最小值，因此其他数初始化为最大值
        dp[0] = 0;
        int max = Integer.MAX_VALUE;
        for (int i = 1; i <= n; i++) {
            dp[i] = max;
        }
        // 4. 求最小值，外层遍历物品或者背包都行
        for (int i = 1; i*i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (j >= i*i) {
                    dp[j] = Math.min(dp[j-i*i] + 1, dp[j]);
                }
            }
        }

        return dp[n];
    }
}
```

## 15. 单词拆分
完全背包：
```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        // 完全背包，背包大小为字符串长度，物品为字符串
        // 1. dp[j]表示字符串长度为j时，背包里的字符串是否满足在字典里出现过
        // 2. 如果字符串子串[i, j]在字典里出现过, 且dp[i]为true，dp[j]也为true)
        // 3. 初始化：dp[0] = true,其他为false
        boolean[] dp = new boolean[s.length()+1];
        dp[0] = true;
        // 4. 遍历顺序，求是否出现，遍历顺序无所谓
        // 但是这里需要先遍历背包，再遍历物品，因为需要截取子串，如果先遍历物品再遍历背包会出现索引出错
        for (int j = 1; j <= s.length(); j++) {
            for (int i = 0; i < j; i++) {
                if (wordDict.contains(s.substring(i, j)) && dp[i]==true) {
                    dp[j] = true;
                }
            }
        }
        return dp[s.length()];
    }
}
```

回溯法：
```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        // 回溯算法，分割问题
        // 1. 确定递归参数
        // 2. 确定终止条件
        // 3. 确定单层递归逻辑
        int[] memory = new int[s.length()]; // 用来记忆startIndex~s.length()是否能够匹配
        return backTracking(s, wordDict, memory, 0);
    }

    public boolean backTracking(String s, List<String> wordDict, int[] memory, int startIndex) {
        if (startIndex >= s.length()) {
            return true;
        }
        if (memory[startIndex] == -1) {
            return false;
        }

        for (int i = startIndex; i < s.length(); i++) {
            String word = s.substring(startIndex, i+1);
            if (wordDict.contains(word) && backTracking(s, wordDict, memory,i+1)) {
                return true;
            }
        }
        // 这里是关键，找遍了startIndex~s.length()也没能完全匹配，标记从startIndex开始不能找到
        memory[startIndex] = -1;
        return false;
    }
}
```

## 多重背包
有n种物品，每种物品有m件，第i种物品的重量为weight[i], 价值为value[i]，将这些物品能装进重量为bagsize的背包中，能够得到的最大价值是？

将m件物品摊开，就可以转化成01背包问题。

## 背包问题总结
![image](https://code-thinking-1253855093.file.myqcloud.com/pics/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%981.jpeg)

## 16. 打家劫舍

```java
class Solution {
    public int rob(int[] nums) {
        // dp问题
        // 1. 确定dp[i]的下标和含义：i以内的房间最大价值
        // 2. 确定dp[i]递推公式：dp[i] = max(dp[i-2] + nums[i], dp[i-1])
        if (nums.length == 1) {
            return nums[0];
        }
        int[] dp = new int[nums.length];
        // 3. 初始化
        dp[0] = nums[0];
        dp[1] = Math.max(nums[1], nums[0]);
        // 4. 遍历顺序,从小到大
        for (int i = 2; i < nums.length; i++) {
            dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);
            System.out.println(dp[i]);
        }
        
        return dp[nums.length - 1];
    }
}
```

## 17. 打家劫舍II

```java
class Solution {
    public int rob(int[] nums) {
        // dp问题
        // 1. 确定dp[i]的下标和含义：i以内的房间最大价值
        // 2. 确定dp[i]递推公式：dp[i] = max(dp[i-2] + nums[i], dp[i-1])
        if (nums.length == 1) {
            return nums[0];
        }

        if (nums.length == 2) {
            return Math.max(nums[0], nums[1]);
        }

        int[] dp1 = new int[nums.length-1]; // 不考虑第一间房
        int[] dp2 = new int[nums.length-1]; // 不考虑最后一间房

        dp1[0] = nums[1];
        dp1[1] = Math.max(nums[2], nums[1]);

        dp2[0] = nums[0];
        dp2[1] = Math.max(nums[1], nums[0]);
        for (int i = 2; i < nums.length; i++) {
            // 不考虑第一间房，所以往后推一间房nums[i+1]
            if (i+1 < nums.length) {
                dp1[i] = Math.max(dp1[i-2] + nums[i+1], dp1[i-1]);
            }
            // 不考虑最后一间房，因此最后一间房不选
            if (i != nums.length - 1) {
                dp2[i] = Math.max(dp2[i-2] + nums[i], dp2[i-1]);
            }
        }
        return Math.max(dp1[nums.length-2], dp2[nums.length-2]);
    }
}
```

这个题解比较清晰

```java
class Solution {
    public int rob(int[] nums) {
        // dp问题
        // 1. 确定dp[i]的下标和含义：i以内的房间最大价值
        // 2. 确定dp[i]递推公式：dp[i] = max(dp[i-2] + nums[i], dp[i-1])
        if (nums.length == 1) {
            return nums[0];
        }
        if (nums.length == 2) {
            return Math.max(nums[0], nums[1]);
        }

        int result1 = robAction(nums, 1, nums.length - 1); // 不考虑第一间房
        int result2 = robAction(nums, 0, nums.length - 2); // 不考虑最后一间房
        return Math.max(result1, result2);
    }

    private int robAction(int[] nums, int start, int end) {
        int[] dp = new int[nums.length];
        dp[start] = nums[start];
        dp[start+1] = Math.max(nums[start], nums[start+1]);

        for (int i = start+2; i <= end; i++) {
            dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);
        }
        return dp[end];
    }
}
```

## 18. 打家劫舍III
直接二叉树后序遍历 + umap记录已经遍历过的子树的最大值
二叉树递归三部曲：
1. 确定参数和返回值
2. 确定终止条件
3. 确定单层递归逻辑
```java
class Solution {
    private Map<TreeNode, Integer> umap = new HashMap<>();
    public int rob(TreeNode root) {
        // 二叉树递归
        // 情况一：如果抢了当前节点，则左右孩子节点就不能抢了
        // 情况二：如果不抢当前节点，则可以抢左右孩子
        // 去上面情况的最大值
        
        // 1. 递归终止条件
        if (root == null) return 0;
        if (root.left == null && root.right == null) return root.val;
        // 如果map中已经有记录，直接返回
        if (umap.containsKey(root)) return umap.get(root);

        // 后序遍历
        // 情况一：如果抢了当前节点，则左右孩子节点就不能抢了
        int val1 = root.val;
        if (root.left != null) val1 = val1 + rob(root.left.left) + rob(root.left.right);
        if (root.right != null) val1 = val1 + rob(root.right.left) + rob(root.right.right);
        
        // 情况二：如果不抢当前节点，则可以抢左右孩子
        int val2 = 0;
        val2 = val2 + rob(root.left) + rob(root.right);

        // 使用map记录
        umap.put(root, Math.max(val1, val2));
        return Math.max(val1, val2);
    }
}
```

树形dp，dp[0]表示不偷当前节点的收益，dp[1]表示偷当前节点的收益，后序遍历从子节点递推到父节点

```java
class Solution {
    public int rob(TreeNode root) {
        int[] dp = robTracking(root);
        return Math.max(dp[0], dp[1]);
    }

    private int[] robTracking(TreeNode root) {
        // 1. 确定dp：dp为一个长度为2的数组dp[0]表示不偷当前节点的收益，dp[1]表示偷当前节点的收益
        // 2. 递归终止条件
        if (root == null) return new int[2];
        int[] dp = new int[2];
        // 3. 确定遍历顺序：后续遍历
        // 4. 确定单层递归逻辑
        int[] left = robTracking(root.left);
        int[] right = robTracking(root.right);

        // 偷当前节点:则子节点就不能偷
        dp[1] = root.val + left[0] + right[0];
        // 不偷当前节点，则选择偷子节点和不偷子节点中的最大值
        dp[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);

        return dp;
    }
}
```
![image](https://code-thinking.cdn.bcebos.com/pics/337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.jpg)


## 20. 买卖股票的最佳时机
暴力法：

```java
class Solution {
    public int maxProfit(int[] prices) {
        // 暴力法，遍历每一天，其后面的最高价格
        int max = 0;
        for (int i = 0; i < prices.length; i++) {
            for (int j = i + 1; j < prices.length; j++) {
                if (prices[j] > prices[i] && prices[j] - prices[i] > max) {
                    max = prices[j] - prices[i];
                }
            }
        }
        return max;
    }
}
```

贪心：

```java
class Solution {
    public int maxProfit(int[] prices) {
        // 贪心：选左边的最小值，选右边的最大值
        int result = 0;
        int low = Integer.MAX_VALUE;
        for (int i = 0; i < prices.length; i++) {
            low = Math.min(prices[i], low);
            result = Math.max(prices[i] - low, result);
        }
        return result;
    }
}
```

动态规划：

```java
class Solution {
    public int maxProfit(int[] prices) {
        // 动态规划
        // 1. 确定dp数组和下标含义：dp[i][0]表示第i天持有股票的收益，dp[i][1]表示第i天不持有股票的收益
        int[][] dp = new int[prices.length][2];
        // 2. 确定递推公式
            // 前一天就持有或者今天买入取最大值：dp[i][0] = Math.max(dp[i-1][0], -prices[i]);
            // 前一天就不持有或者今天抛售取最大值：dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]);
        // 3. 初始化
        dp[0][0] = -prices[0];
        dp[0][1] = 0; 

        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i-1][0], -prices[i]);
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]);
        }

        // 不持有股票收益肯定最大
        return dp[prices.length - 1][1];
    }
}

```
动态规划：滚动数组优化空间

```java
// 滚动数组优化空间
class Solution {
    public int maxProfit(int[] prices) {
        // 动态规划
        // 1. 确定dp数组和下标含义：dp[i][0]表示第i天持有股票的收益，dp[i][1]表示第i天不持有股票的收益
        int[][] dp = new int[2][2]; //所有的dp[i]都依赖于dp[i-1]因此可以用滚动数组优化空间
        // 2. 确定递推公式
        // 3. 初始化
        dp[0][0] = -prices[0];
        dp[0][1] = 0; 

        for (int i = 1; i < prices.length; i++) {
            dp[i % 2][0] = Math.max(dp[(i-1) % 2][0], -prices[i]);
            dp[i % 2][1] = Math.max(dp[(i-1) % 2][1], dp[(i-1) % 2][0] + prices[i]);
        }

        // 不持有股票收益肯定最大
        return dp[(prices.length - 1) % 2][1];
    }
}
```

## 21. 买卖股票的最佳时机II

```java
class Solution {
    public int maxProfit(int[] prices) {
        // 动态规划
        // 1. 确定dp含义和下标：dp[i][0]表示第i天持有股票的最大收益，dp[i][1]表示第i天不持有股票的最大收益
        // 2. 确定递推公式
            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])
            // dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])

        int[][] dp = new int[prices.length][2];
        // 3. 初始化
        dp[0][0] = - prices[0];
        dp[0][1] = 0;

        // 4. 确定遍历顺序
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] - prices[i]);
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]);
        }

        return dp[prices.length - 1][1];
    }
}
```

滚动数组：

```java
class Solution {
    public int maxProfit(int[] prices) {
        // 动态规划
        // 1. 确定dp含义和下标：dp[i][0]表示第i天持有股票的最大收益，dp[i][1]表示第i天不持有股票的最大收益
        // 2. 确定递推公式
            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])
            // dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])

        int[][] dp = new int[2][2];
        // 3. 初始化
        dp[0][0] = - prices[0];
        dp[0][1] = 0;

        // 4. 确定遍历顺序
        for (int i = 1; i < prices.length; i++) {
            dp[i % 2][0] = Math.max(dp[(i-1) % 2][0], dp[(i-1) % 2][1] - prices[i]);
            dp[i % 2][1] = Math.max(dp[(i-1) % 2][1], dp[(i-1) % 2][0] + prices[i]);
        }

        return dp[(prices.length - 1) % 2][1];
    }
}
```

## 22. 买卖股票的最佳时机III

```java
class Solution {
    public int maxProfit(int[] prices) {
        // 1. 确定dp数组的下标和含义dp[i][j]
            // dp[i][0]表示没有操作
            // dp[i][1]表示第一次买入
            // dp[i][2]表示第一次卖出
            // dp[i][3]表示第二次买入
            // dp[i][4]表示第二次卖出
        // 2. 确定递推公式
            // dp[i][0] = dp[i-1][0];
            // dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]);
            // dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1] + prices[i]);
            // dp[i][3] = Math.max(dp[i-1][3], dp[i-1][2] - prices[i]);
            // dp[i][4] = Math.max(dp[i-1][4], dp[i-1][3] + prices[i]);
        int[][] dp = new int[prices.length][5];

        // 3. 初始化
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;
        
        // 4. 确定遍历顺序
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = dp[i-1][0];
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]);
            dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1] + prices[i]);
            dp[i][3] = Math.max(dp[i-1][3], dp[i-1][2] - prices[i]);
            dp[i][4] = Math.max(dp[i-1][4], dp[i-1][3] + prices[i]);
        }

        return dp[prices.length-1][4];
    }
}
```

## 23. 买卖股票的最佳时机IV

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        // 1. 确定dp[i][j]的下标和含义
            // dp[i][j]
            // 当 j 为 奇数，表示买入
            // 当 j 为 偶数，表示卖出
        // 2. 确定dp[i][j]的递推公式
            // dp[i][0] = dp[i-1][0]; 这里不操作的话就一直是0，所以dp[i][0]=0
            // dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]);
            // dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1] + prices[i]);
            // ...
        if (prices == null || prices.length == 0) return 0; // 异常情况

        int[][] dp = new int[prices.length][2 * k + 1];

        // 3. 初始化
        for (int j = 1; j < 2 * k + 1; j+=2) {
            // 买入的情况
            dp[0][j] = -prices[0];
        }

        // 4. 确定遍历顺序
        for (int i = 1; i < prices.length; i++) {
            for (int j = 1; j < 2 * k + 1; j++) {
                if (j % 2 == 1) {
                    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-1] - prices[i]);
                } else {
                    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-1] + prices[i]);
                }
            }
        }
        return dp[prices.length - 1][2 * k];
    }
}
```

优化遍历顺序

```java
// 4. 确定遍历顺序
for (int i = 1; i < prices.length; i++) {
    for (int j = 0; j < 2 * k - 1; j+=2) {
        dp[i][j+1] = Math.max(dp[i-1][j+1], dp[i-1][j] - prices[i]);
        dp[i][j+2] = Math.max(dp[i-1][j+2], dp[i-1][j+1] + prices[i]);
        }
    }
}
```



## 24. 最佳买卖股票时机含冷冻期

```java
class Solution {
    public int maxProfit(int[] prices) {
        // 1. 确定dp[i][j]含义和下标：dp为最大收益
            // 1. dp[i][0]表示买入股票的状态
            // 2. dp[i][1]表示卖出股票的状态I：两天前就卖出了股票，度过了冷冻期
            // 3. dp[i][2]表示卖出股票的状态II：今天卖出了股票
            // 4. dp[i][3]表示冷冻期的状态：昨天卖出了股票, 今天为冷冻期
        // 2. 确定dp数组的递推公式
            // dp[i][0] = Math.max(dp[i-1][0], Math.max(dp[i-1][1] - prices[i], dp[i-1][3]-prices[i]));
            // dp[i][1] = Math.max(dp[i-1][1], dp[i-1][3]);
            // dp[i][2] = dp[i-1][0] + prices[i];
            // dp[i][3] = dp[i-1][2];
        int[][] dp = new int[prices.length][4];
        // 3. 初始化
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        dp[0][2] = 0;
        dp[0][3] = 0;
        // 4. 遍历顺序
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i-1][0], Math.max(dp[i-1][1] - prices[i], dp[i-1][3]-prices[i]));
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][3]);
            dp[i][2] = dp[i-1][0] + prices[i];
            dp[i][3] = dp[i-1][2];
        }

        return Math.max(Math.max(dp[prices.length - 1][1], dp[prices.length - 1][2]), dp[prices.length - 1][3]);
    }
}
```
滚动数组优化空间：dp[2][4]，对原代码的 i % 2 即可

```java
class Solution {
    public int maxProfit(int[] prices) {
        // 1. 确定dp[i][j]含义和下标：dp为最大收益
            // 1. dp[i][0]表示买入股票的状态
            // 2. dp[i][1]表示卖出股票的状态I：两天前就卖出了股票，度过了冷冻期
            // 3. dp[i][2]表示卖出股票的状态II：今天卖出了股票
            // 4. dp[i][3]表示冷冻期的状态：昨天卖出了股票, 今天为冷冻期
        // 2. 确定dp数组的递推公式
            // dp[i][0] = Math.max(dp[i-1][0], Math.max(dp[i-1][1] - prices[i], dp[i-1][3]-prices[i]));
            // dp[i][1] = Math.max(dp[i-1][1], dp[i-1][3]);
            // dp[i][2] = dp[i-1][0] + prices[i];
            // dp[i][3] = dp[i-1][2];
        int[][] dp = new int[2][4];
        // 3. 初始化
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        dp[0][2] = 0;
        dp[0][3] = 0;
        // 4. 遍历顺序
        for (int i = 1; i < prices.length; i++) {
            dp[i % 2][0] = Math.max(dp[(i-1)%2][0], Math.max(dp[(i-1)%2][1] - prices[i], dp[(i-1)%2][3]-prices[i]));
            dp[i % 2][1] = Math.max(dp[(i-1)%2][1], dp[(i-1)%2][3]);
            dp[i % 2][2] = dp[(i-1)%2][0] + prices[i];
            dp[i % 2][3] = dp[(i-1)%2][2];
        }

        return Math.max(Math.max(dp[(prices.length - 1)%2][1], dp[(prices.length - 1)%2][2]), dp[(prices.length - 1)%2][3]);
    }
}
```

## 25. 买卖股票的最佳时机含手续费

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        // 1. dp[i][j]代表最大收益
            // dp[i][0]表示持有股票的最大收益
            // dp[i][1]表示不持有股票的最大收益
        // 2. dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] - prices[i]);
        //    dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i] - fee);
        int[][] dp = new int[prices.length][2];

        // 3. 初始化
        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        // 4. 遍历顺序
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] - prices[i]);
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i] - fee);
        }

        return dp[prices.length-1][1];
    }
}
```

## 股票买卖问题总结
![image](https://code-thinking.cdn.bcebos.com/pics/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.jpg)

## 26. 最长递增子序列

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        // 最长递增子序列
        // 1. dp[i]表示i之前包括i以nums[i]结尾最长上升子序列的长度
        // 2. 如果nums[i] > nums[j]， dp[i] = Math.max(dp[i], dp[j] + 1)
        int[] dp = new int[nums.length];
        // 3. 初始化
        // 可以用Arrays.fill(dp, 1)替代
        for (int i = 0; i < nums.length; i++) { 
            dp[i] = 1;
        }
        // 4. 遍历顺序
        int res = 1;
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            if (dp[i] > res) {
                res = dp[i];
            }
        }
        return res;
    }
}
```

## 27. 最长连续递增子序列

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        // 1. 确定dp[i]下标和含义: 前i个元素包括i以nums[i]结尾的最长连续递增子序列
        // 2. 如果nums[i] > nums[i-1]: dp[i] = dp[i-1] + 1;
        int[] dp = new int[nums.length];
        // 3. 初始化
        Arrays.fill(dp, 1);
        int res = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > nums[i-1]) {
                dp[i] = dp[i-1] + 1;
            }
            if (dp[i] > res) {
                res = dp[i];
            }
        }
        return res;
    }
}
```

## 28. 最长重复子数组

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        // 1. dp[i][j]表示A数组中下标为i-1的元素结尾，B数组中下标为j-1的元素结尾，最长的子数组长度
            // 这里下标定为i-1和j-1是为了省略初始化dp[0][j]和dp[i][0]的步骤
        // 2. 如果nums[i] == nums[j] 则 dp[i][j] = dp[i-1][j-1];
        int[][] dp = new int[nums1.length+1][nums2.length+1];
        // 3. 初始化，初始化为0即可
        // 4. 遍历顺序
        int res = 0;
        for (int i = 1; i <= nums1.length; i++) {
            for (int j = 1; j <= nums2.length; j++) {
                if (nums1[i-1] == nums2[j-1]) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                if (dp[i][j] > res) {
                    res = dp[i][j];
                }
            }      
        }
        return res;
    }
}
```
滚动数组：

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        // 滚动数组
        int[] dp = new int[nums2.length+1];
        int res = 0;
        for (int i = 1; i <= nums1.length; i++) {
            // 遍历B数组的时候，就要从后向前遍历，这样避免重复覆盖
            for (int j = nums2.length; j > 0; j--) {
                if (nums1[i-1] == nums2[j-1]) {
                    dp[j] = dp[j-1] + 1;
                } else {
                    dp[j] = 0; // 这里不相等需要赋0
                }
                if (dp[j] > res) {
                    res = dp[j];
                }
            }      
        }
        return res;
    }
}
```

## 29. 最长公共子序列

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        // 1. dp[i][j]表示text1[0, i-1]和text2[0, j-1]的最长公共子序列
        // 2. 如果text1[i-1] == text2[j-1], 则dp[i][j] = dp[i-1][j-1] + 1;
        //    如果text1[i-1] != text2[j-1], 则dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
        int[][] dp = new int[text1.length()+1][text2.length()+1];
        // 3. 初始化:dp[0][j]和dp[i][0]都初始化为0
        // 4. 遍历顺序
        for (int i = 1; i <= text1.length(); i++) {
            for (int j = 1; j <= text2.length(); j++) {
                if (text1.charAt(i-1) == text2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        return dp[text1.length()][text2.length()];   
    }
}
```

## 30. 不相交的线

不相交的线其实求的是两个字符串的最长公共子序列

```java
class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        // 题意转换，本题其实求的是两个字符串的最长公共子序列
        // 1. dp[i][j]为nums1[0, i-1]和nums2[0, j-1]的子串的最长公共子序列
        // 2. 当nums1[i-1] == nums2[j-1]时，dp[i][j] = dp[i-1][j-1] + 1;
        //    当nums1[i-1] != nums2[j-1]时，dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
        int[][] dp = new int[nums1.length+1][nums2.length+1];
        // 3. 初始化，dp[0][j] = 0, dp[i][0] = 0, 其他也为0
        // 4. 遍历顺序
        for (int i = 1; i <= nums1.length; i++) {
            for (int j = 1; j <= nums2.length; j++) {
                if (nums1[i-1] == nums2[j-1]) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        return dp[nums1.length][nums2.length];
    }
}
```

## 31. 最大子数组和

```java
class Solution {
    public int maxSubArray(int[] nums) {
        // 1. dp[i]表示前i个元素以下标i元素结尾的最大连续和
        // 2.  dp[i] = Math.max(dp[i-1] + nums[i], nums[i]);
        int[] dp = new int[nums.length];
        // 3. 初始化
        dp[0] = nums[0];
        // 4. 遍历顺序
        int res = dp[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(dp[i-1] + nums[i], nums[i]);
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

## 32. 判断子序列

其实和求两个数的最长子序列是一样的，最后只要看最长子序列的长度是否等于给定字符串的长度即可

当然这道题是编辑距离的入门题目，如果 s[i-1] != t[j-1] 则 t 需要删除当前元素

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        // 1. dp[i][j]表示s中以i-1为下标的元素结尾，t中以j-1为下标的元素结尾相同子序列的长度
        // 2. 当s[i-1] == j[j-1]时，dp[i][j] = dp[i-1][j-1] + 1;
            // 当s[i-1] != j[j-1]，dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j])
            // 当s[i-1] != j[j-1]，也可以这样子理解：
                // 相当于要删除t中的元素，则只需要看s[i-1]和t[j-2]的比较结果，即dp[i][j] = dp[i][j-1]
        int[][] dp = new int[s.length()+1][t.length()+1];
        // 3. 初始化
        // 4. 遍历顺序
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 1; j <= t.length(); j++) {
                if (s.charAt(i-1) == t.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else {
                    //dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j]);
                    dp[i][j] = dp[i][j-1];
                }
            }
        } 
        return dp[s.length()][t.length()] == s.length();
    }
}
```

## 33. 不同的子序列

```java
class Solution {
    public int numDistinct(String s, String t) {
        // 1. dp[i][j]表示s中以下标i-1元素结尾的子序列出现以j-1结尾的t的个数
        // 2. 当s[i-1] == t[j-1]时，dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
            // 当s[i-1] != t[j-1]时，dp[i][j] = dp[i-1][j]
        int[][] dp = new int[s.length()+1][t.length()+1];
        // 3. 初始化
        for (int i = 0; i <= s.length(); i++) {
            // 相当于让s匹配空串，即将s所有的字符删除
            dp[i][0] = 1;
        }
        // dp[0][j] = 0; s为空串，肯定匹配不上t

        // 4. 遍历顺序
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 1; j <= t.length(); j++) {
                if (s.charAt(i-1) == t.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                } else {
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[s.length()][t.length()];
    }
}
```

## 34. 两个字符串的删除操作

```java
class Solution {
    public int minDistance(String word1, String word2) {
        // 1. dp[i][j]表示word1中以i-1结尾的子序列，word2中以j-1结尾的子序列，两者相同所需要删除的最小步数
        // 2. 当word1[i-1] == word2[j-1]时，即不需要删除，dp[i][j] = dp[i-1][j-1];
            //当word1[i-1] != word2[j-1]时，删除i-1或者删除j-1或者删除i-1和j-1，取其中的最小值，即 dp[i][j] = Math.min(dp[i-1][j-1]+2, Math.min(dp[i-1][j]+1, dp[i][j-1]+1));
        int[][] dp = new int[word1.length()+1][word2.length()+1];
        // 3. 初始化,dp[i][0] = i, dp[0][j] = j
        for (int i = 0; i <= word1.length(); i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j <= word2.length(); j++) {
            dp[0][j] = j;
        }
        // 4. 遍历顺序
        for (int i = 1; i <= word1.length(); i++) {
            for (int j = 1; j <= word2.length(); j++) {
                if (word1.charAt(i-1) == word2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = Math.min(dp[i-1][j-1]+2, Math.min(dp[i-1][j]+1, dp[i][j-1]+1));
                }
            }
        }
        return dp[word1.length()][word2.length()];
    }
}
```
思路2：求两字符的最长公共子序列，最后将两字串符长度减去最长公共子序列的长度就是最小操作步数

```java
class Solution {
    public int minDistance(String word1, String word2) {
        // 思路2：求两字符串的最大相同子序列，然后将word1和word2长度与之想减就能求出步数
        int[][] dp = new int[word1.length()+1][word2.length()+1];
        for (int i = 1; i <= word1.length(); i++){
            for (int j =1; j <= word2.length(); j++) {
                if (word1.charAt(i-1) == word2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        return (word1.length() - dp[word1.length()][word2.length()]) + (word2.length() - dp[word1.length()][word2.length()]);
    }
}
```

## 35. 编辑距离

```java
class Solution {
    public int minDistance(String word1, String word2) {
        // 1. dp[i][j]表示word1中以i-1元素结尾，word2中以j-1元素结尾，最小的编辑距离
        // 2. 当word1[i-1] == word2[j-1] 时，dp[i][j] = dp[i-1][j-1];
            //当word1[i-1] != word2[j-1] 时，dp[i][j] = Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+1) (对应删除word1元素，删除word2元素，替换word1中的元素)
        int[][] dp = new int[word1.length()+1][word2.length()+1];
        // 3. 初始化
        for (int i = 0; i <= word1.length(); i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j <= word2.length(); j++) {
            dp[0][j] = j;
        }
        // 4. 确定遍历顺序
        for (int i = 1; i <= word1.length(); i++) {
            for (int j = 1; j <= word2.length(); j++) {
                if (word1.charAt(i-1) == word2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = Math.min(dp[i-1][j]+1, Math.min(dp[i][j-1]+1, dp[i-1][j-1]+1));
                }
            }
        }
        return dp[word1.length()][word2.length()];
    }
}
```

## 36. 回文子串

```java
class Solution {
    public int countSubstrings(String s) {
        // 1. dp[i][j]表示区间[i,j]是否为回文串，是dp[i][j]为true，否则为false
        // 2. 当s[i] == s[j]时，如果j==i或者j-i==1，例如a和aa，则dp[i][j] = true，否则dp[i][j] = dp[i+1][j-1];
            //当s[i] != s[j]时, dp[i][j] = false;
        boolean[][] dp = new boolean[s.length()][s.length()];
        // 3. 初始化，全部初始化为false
        // 4. 遍历顺序，因为dp[i][j]需要根据dp[i+1][j-1]推导出来，因此需要从下到上，从左到右遍历
        int res = 0;
        for (int i = s.length()-1; i >= 0; i--) {
            for (int j = i; j < s.length(); j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    if (j - i <= 1) {
                        res++;
                        dp[i][j] = true;
                    } else if(dp[i+1][j-1]) {
                        res++;
                        dp[i][j] = dp[i+1][j-1];
                    }
                } 
            }
        }
        return res;
    }
}
```

双指针法：

```java
class Solution {
    public int countSubstrings(String s) {
        // 双指针法：找中心然后向两边扩散
        // 1. 中心为单字符
        // 2. 中心为双字符
        int res = 0;
        for (int i = 0; i < s.length(); i++) {
            res += extend(s, i, i, s.length());
            res += extend(s, i, i+1, s.length());
        }
        return res;
    }

    private int extend(String s, int i, int j, int l) {
        int res = 0;
        while (i >= 0 && j < l) {
            if (s.charAt(i) == s.charAt(j)) {
                res++;
            } else { // 当两边不相等时直接break，不需要继续验证了
                break;
            }
            i--;
            j++;
        }
        return res;
    }
}
```

## 37. 最长回文子序列

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        // 1. dp[i][j]表示区间[i,j]的最长回文子序列
        // 2. 当s[i] == s[j]时，dp[i][j] = dp[i+1][j-1] + 2;
            //当s[i] != s[j]时, dp[i][j] = Math.max(dp[i][j-1], dp[i+1][j], dp[i+1][j-1]);(分别表示保留s[i],保留s[j],两者都不保留)
        int[][] dp = new int[s.length()][s.length()];
        // 3. 初始化, 当i==j时，初始化为1
        for (int i = 0; i < s.length(); i++) {
            dp[i][i] = 1;
        }
        // 4. 遍历顺序:因为dp[i][j]依赖于dp[i][j-1], dp[i+1][j], dp[i+1][j-1], 从下到上，从左到右
        for (int i = s.length() - 1; i >= 0; i--) {
            for (int j = i + 1; j < s.length(); j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i+1][j-1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i][j-1], Math.max(dp[i+1][j], dp[i+1][j-1]));
                }
            }
        }
        return dp[0][s.length()-1];
    }
}
```



