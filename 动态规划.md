# 动态规划
## 理论基础
[理论基础](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)

dp五部曲：
1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 1. 斐波那契数

简单题目用来搞懂动态规划的五部曲：
1. 确定dp数组以及下标的含义
dp[i]的定义为：第i个数的斐波那契数值是dp[i]
2. 确定递推公式
题目已经直接给了：dp[i] = dp[i - 1] + dp[i - 2];
3. dp数组如何初始化
题目也给了dp[0] = 0, dp[1] = 1;
4. 确定遍历顺序
从递归公式dp[i] = dp[i - 1] + dp[i - 2]可以看出，dp[i] 是依赖 dp[i-1] 和 dp[i-2]的，那么遍历顺序就是从前向后遍历
5. 举例推导dp数组
例如n=10时，dp数组应该为：0 1 1 2 3 5 8 13 21 34 55，如果代码写出来结果不对，则把dp数组打印出来看看和我们推导的数列是不是一致


### 方法一
```java
class Solution {
    public int fib(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;

        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

### 方法二：数组只需要两个元素即可

```java
class Solution {
    public int fib(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;

        // 只需要维护两个元素即可
        int[] dp = new int[2];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            int sum = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = sum;
        }
        return dp[1];
    }
}
```

## 2. 爬楼梯



```java
class Solution {
    public int climbStairs(int n) {
        // 动态规划
        // 1. 确定dp数组以及下标的含义：dp[i]是爬到i层楼梯的方法
        // 2. 确定递推公式：dp[i-1]跨1步可以到dp[i]，dp[i-2]跨2个台阶可以到达dp[i]，因为到达第i层的方法数dp[i] = dp[i-1] + dp[i-2]
        // 3. dp数组如何初始化：不需要考虑dp[0]，dp[1]=1, dp[2]=2;
        // 4. 确定遍历顺序：从前往后遍历
        // 5. 举例推导dp数组

        if (n <= 2) return n;

        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;

        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2]; 
        }

        return dp[n];

    }
}
```

思考：如果一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法可以爬到楼顶，这个时候就需要dp[i] = dp[i-1] + dp[i-2] + ... + dp[i-m];

```java
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) { // 把m换成2，就可以AC爬楼梯这道题
        if (i - j >= 0) dp[i] += dp[i - j];
    }
}
```


## 3. 使用最小花费爬楼梯

思路：
1. 确定dp数组和下标：dp[i]是到达第i个台阶所花费的最少体力，包括自己的这一层的花费
2. 确定递推公式：dp[i]可以通过dp[i-1]和dp[i-2]获得，这里选最小的dp[i] = min(dp[i-1], dp[i-2]) + cost[i]，注意这里是cost[i], 表示到该层再往上的花费
3. dp数组的初始化：dp[0] = cost[0], dp[1] = cost[1]
4. 确定遍历顺序：从前往后遍历
5. 举例推导dp数组: 如果代码结果不对的话 
6. 注意最后一步：最后一步，如果是由倒数第二步爬，则最后一步的体力花费可以不用算

```
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        // 动态规划
        // 1. 确定dp数组和下标：dp[i]是到达第i个台阶所花费的最少体力，包括自己的这一层的花费
        // 2. 确定递推公式：dp[i]可以通过dp[i-1]和dp[i-2]获得，这里选最小的dp[i] = min(dp[i-1], dp[i-2]) + cost[i]，注意这里是cost[i], 表示到该层再往上的花费
        // 3. dp数组的初始化：dp[0] = cost[0], dp[1] = cost[1]
        // 4. 确定遍历顺序：从前往后遍历
        // 5. 举例推导dp数组: 如果代码结果不对的话
        
        if (cost == null || cost.length == 0) return 0;
        if (cost.length == 1) return cost[0];

        int[] dp = new int[cost.length];
        dp[0] = cost[0];
        dp[1] = cost[1];

        for (int i = 2; i < cost.length; i++) {
            dp[i] = Math.min(dp[i-1], dp[i-2]) + cost[i];
        }

        //最后一步，如果是由倒数第二步爬，则最后一步的体力花费可以不用算
        return Math.min(dp[cost.length - 1], dp[cost.length-2]);
    }
}
```

## 4. 不同路径

![image](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

```java
class Solution {
    public int uniquePaths(int m, int n) {
        // 1. 确定dp数组以及下标：dp[i][j] 表示到（i,j）有多少条路径
        // 2. 确定dp数组的递推公式：其从左边过来或者从上边过来，则 dp[i][j] = dp[i-1][j] + dp[i][j-1];
        // 3. 确定dp数组的初始化值：其最上方和最左方的值一定为1: dp[0][i] = 0; dp[i][0] = 0;
        // 4. 确定dp数组的遍历顺序：一层一层从左到右遍历可以保证其上方和左方一定有数值
        // 5. 如果ac不了，打印数组来对比

        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int i = 0; i < n; i++) dp[0][i] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```

## 5. 不同路径II

思路：
- 增加了障碍物
- 在有障碍物的地方保持0即可

![image](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        // 1. 确定dp数组下标：dp[i][j] 表示到（i，j）有多少条路径
        // 2. 确定dp数组的推导：dp[i][j] = dp[i-1][j] + dp[i][j-1]
        // 3. 确定dp数组的初始化：有障碍的地方保持0即可，最左边和最右边初始化为1，但是如果遇到障碍，障碍左边和障碍下边初始化为0
        // 4. 确定dp数组的遍历顺序，一层一层从左到右，有障碍的地方保持0即可
        // 5. 打印..

        int x = obstacleGrid.length;
        int y = obstacleGrid[0].length;
        int[][] dp = new int[x][y];

        for (int i = 0; i < x; i++) {
            if (obstacleGrid[i][0] == 1) break; //一旦遇到障碍，后续都到不了
            dp[i][0] = 1;
        }
        for (int i = 0; i < y; i++) {
            if (obstacleGrid[0][i] == 1) break; //一旦遇到障碍，后续都到不了
            dp[0][i] = 1;
        }
        for (int i = 1; i < x; i++) {
            for (int j = 1; j < y; j++) {
                if (obstacleGrid[i][j] == 1) continue; // 有障碍物的地方，保持0
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[x-1][y-1];
    }
}
```

## 6. 整数拆分

思路：
1. dp[i]表示i的最大乘积
2. 设定 j 从 1 到 i-1，则取遍历过程中的最大值：dp[i] = max(dp[i], j * (i - j), j * dp[i - j])，其中j * (i - j)表示把 dp 分成两个数相乘，j * dp[i - j] 表示把 dp 分解成两个数以上相乘。为什么要加上dp[i]则是在遍历j的过程中取最大值。

```java
class Solution {
    public int integerBreak(int n) {
        // 1. dp数组定义和下标：dp[i]表示i的最大乘积
        // 2. dp数组的递推：j从1开始，dp[i] = max(dp[i], j*(i-j), j*dp[i-j])
        // 3. dp数组的初始化：从2开始：dp[2] = 1
        // 4. dp数组的初始化顺序
        // 5. 打印..

        int[] dp = new int[n + 1];
        dp[2] = 1;
        for (int i = 3; i <= n; i++) {
            for (int j = 1; j < i - 1; j++) {
                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
            }
        }
        return dp[n];
    }
}
```

## 7. 不同的二叉搜索树

思路：
1. 先确定树为二叉搜索树，左子节点比父节点小，右子节点比父节点大
2.  dp[i]: 1到i为节点组成的二叉搜索树的个数为dp[i]。
3. 递推公式：dp[i] += dp[j-1] * dp[i-j] dp[j-1]为左节点，dp[i-j]为右节点个数，j的范围从1~i

```java
class Solution {
    public int numTrees(int n) {
        // 确定dp[i]的含义和下标： 1到i为节点组成的二叉搜索树的个数为dp[i]。
        // 确定dp数组的递推公式：dp[i] += dp[j-1] * dp[j-i]
        // 确定初始化顺序：dp[0] = 1
        // 确定遍历顺序：从前往后
        // 打印
        
        int[] dp = new int[n+1];
        dp[0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                //对于第i个节点，需要考虑1作为根节点直到i作为根节点的情况，所以需要累加
                //一共i个节点，对于根节点j时,左子树的节点个数为j-1，右子树的节点个数为i-j
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }

        return dp[n];
    }
}
```

## 8. 分割等和子集

思路：
1. 使用01背包，设定背包容量为sum/2
2. 当背包容量sum/2时其最大重量dp[sum/2] == sum/2时，则表示可以分割

```java
class Solution {
    public boolean canPartition(int[] nums) {
        // 01背包
        // 背包的体积为sum / 2
        // dp[j] = Math.max(dp[j], dp[j-nums[i]] + nums[i]);

        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
        }

        if(sum%2 != 0) return false;
        int[] dp = new int[sum/2 + 1];

        for (int i = 0; i < nums.length; i++) {
            for (int j = sum / 2; j >= nums[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j-nums[i]] + nums[i]);
            }
        }

        return dp[sum / 2] == sum / 2;
    }
}
```

